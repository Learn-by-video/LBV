<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>L.B.V. - Main Page</title>

  <!-- Note: description removed as requested -->

  <meta name="keywords" content="L.B.V, Learn by Video, educational platform, facts, videos, games, learning" />
  <meta name="author" content="L.B.V. Team" />

  <link id="page-favicon" rel="icon" type="image/png" href="https://raw.githubusercontent.com/Learn-by-video/assets/refs/heads/main/Favcon/l-b-v.jpg">
  <meta name="theme-color" content="#003366">

  <style>
    html, body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #003366;
      color: white;
      text-align: center;
      min-height: 100vh;
    }
    header, footer {
      padding: 20px;
      background: #003366;
    }
    .nav-links { display:flex; gap:12px; justify-content:center; padding:16px; flex-wrap:wrap; }
    .nav-links a { background:white; color:#003366; padding:12px 18px; border-radius:6px; text-decoration:none; font-weight:bold; }
    .version-banner { position: fixed; bottom: 10px; width: 100%; text-align: center; font-size: 0.95em; opacity: 0.8; }

    /* Modal & controls */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      padding: 18px;
    }
    .modal {
      background: #0b0b0b;
      color: #fff;
      border-radius: 12px;
      padding: 20px;
      max-width: 780px;
      width: 100%;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
      text-align: left;
    }
    .modal h2 { margin: 0 0 8px 0; font-size: 20px; text-align:center; }
    label { color:#cfd8dc; font-size:13px; display:block; margin-bottom:6px; }
    textarea { width:100%; min-height:140px; resize:vertical; padding:10px; border-radius:8px; border:none; background:#071017; color:#e6f7f7; font-size:14px; }
    input[type="number"], input[type="text"], select { padding:8px 10px; border-radius:8px; border:none; background:#071017; color:#e6f7f7; font-size:14px; }
    .controls { display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; align-items:center; }
    .btn { background: #00f2ea; color: #000; padding:10px 16px; border-radius:10px; border:none; font-weight:700; cursor:pointer; }
    .btn.secondary { background:#2b2b2b; color:#fff; border:1px solid #444; box-shadow:none; }
    .small { font-size:12px; color:#9aa7ac; }
    .row { display:flex; gap:10px; align-items:center; margin-top:8px; flex-wrap:wrap; }
    .col { display:flex; flex-direction:column; gap:6px; }

    .list-actions { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center; }

    @media (max-width:700px) {
      .modal { padding:14px; }
      textarea { min-height:110px; }
      .controls { flex-direction:column; align-items:stretch; }
    }
  </style>
</head>
<body>

<header>
  <a href="index.html" style="color:white; text-decoration:none; font-size:22px; font-weight:bold;">L.B.V. - Learn by Video</a>
  <!-- description removed as requested -->
</header>

<div class="nav-links">
  <a href="/lbv/facts/">Facts</a>
  <a href="/lbv/videos/">Videos</a>
  <a href="/lbv/games/">Games</a>
</div>

<footer>
  <p style="margin:0;">© Learn by Video. All rights reserved.</p>
</footer>

<div class="version-banner">
  Site Version: <span id="siteVersion">Loading...</span>
</div>

<!-- Modal (only opened by shortcut Ctrl+Alt+Shift+Z) -->
<div id="historyModalOverlay" class="modal-overlay" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="modal" role="document">
    <h2>History Flood Tool</h2>

    <label for="sitesList">Sites (one per line) — loaded from urls.txt automatically. You can edit, add, or remove entries here. Changes are saved to local storage and can be downloaded as a new urls.txt.</label>
    <textarea id="sitesList" placeholder="https://example.com/page
https://another.example/path"></textarea>

    <div class="list-actions">
      <input id="addUrlInput" type="text" placeholder="Add a URL and press Add" style="flex:1; min-width:200px;" />
      <button id="addUrlBtn" class="btn">Add</button>
      <button id="removeSelectedBtn" class="btn secondary">Remove Selected Lines</button>
      <button id="downloadBtn" class="btn">Download urls.txt</button>
      <span id="loadedCount" class="small">Loading...</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="col" style="flex:0 0 160px;">
        <label class="small" for="cycles">Cycles</label>
        <input id="cycles" type="number" min="1" value="1" />
      </div>
      <div class="col" style="flex:0 0 200px;">
        <label class="small" for="capPerCycle">Max pushes per cycle (optional)</label>
        <input id="capPerCycle" type="number" min="1" placeholder="leave blank = all" />
      </div>
      <div class="col" style="flex:0 0 160px;">
        <label class="small" for="useFullPath">Push type</label>
        <select id="useFullPath">
          <option value="path">/flood/?u=[url]</option>
          <option value="hash">#/flood/?u=[url]</option>
        </select>
      </div>
    </div>

    <div class="controls" style="margin-top:12px;">
      <button id="startFloodBtn" class="btn">Start Flood (from list)</button>
      <button id="previewBtn" class="btn secondary">Preview first 5 entries</button>
      <button id="closeModalBtn" class="btn secondary">Close</button>
    </div>

    <div style="margin-top:12px; text-align:center;" class="small">
      Open this tool with Ctrl + Alt + Shift + Z
    </div>
  </div>
</div>

<script>
  // fetch version if available
  (function fetchVersion(){
    fetch('/version.txt?nocache=' + Date.now())
      .then(r => r.text())
      .then(t => { document.getElementById('siteVersion').textContent = t.trim(); })
      .catch(() => { document.getElementById('siteVersion').textContent = 'Unavailable'; });
  })();

  // Modal open/close only via Ctrl+Alt+Shift+Z or Escape to close
  (function() {
    const overlay = document.getElementById('historyModalOverlay');
    const closeBtn = document.getElementById('closeModalBtn');

    function openModal() {
      overlay.style.display = 'flex';
      overlay.setAttribute('aria-hidden', 'false');
      document.getElementById('sitesList').focus();
    }
    function closeModal() {
      overlay.style.display = 'none';
      overlay.setAttribute('aria-hidden', 'true');
    }

    closeBtn.addEventListener('click', closeModal);
    overlay.addEventListener('click', function(e){ if (e.target === overlay) closeModal(); });

    document.addEventListener('keydown', function(e){
      if (e.ctrlKey && e.altKey && e.shiftKey && (e.key === 'Z' || e.key === 'z')) {
        e.preventDefault();
        if (overlay.style.display === 'flex') closeModal(); else openModal();
      }
      if (e.key === 'Escape' && overlay.style.display === 'flex') closeModal();
    });

    // Expose for debugging if needed
    window.openHistoryModal = openModal;
    window.closeHistoryModal = closeModal;
  })();

  // Main behavior: auto-load urls.txt on page load, merge with local storage extras, allow edits and download.
  (function() {
    const sitesTextarea = document.getElementById('sitesList');
    const loadedCountEl = document.getElementById('loadedCount');
    const addUrlInput = document.getElementById('addUrlInput');
    const addUrlBtn = document.getElementById('addUrlBtn');
    const removeSelectedBtn = document.getElementById('removeSelectedBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    const startFloodBtn = document.getElementById('startFloodBtn');
    const previewBtn = document.getElementById('previewBtn');
    const cyclesInput = document.getElementById('cycles');
    const capPerCycleInput = document.getElementById('capPerCycle');
    const useFullPathSelect = document.getElementById('useFullPath');

    const SAFETY_CAP = 5000;
    const STORAGE_KEY = 'historyFlood.extraUrls';

    // Helper: parse text into unique array
    function parseSites(text) {
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const seen = new Set();
      const out = [];
      for (const l of lines) {
        if (!seen.has(l)) { seen.add(l); out.push(l); }
      }
      return out;
    }

    // Save current textarea to localStorage extras (user additions)
    function saveExtrasFromTextarea() {
      const current = parseSites(sitesTextarea.value);
      // We keep everything in textarea in localStorage as "extras"
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(current));
      } catch (e) {
        console.warn('Could not save to localStorage', e);
      }
    }

    // Download current textarea contents as urls.txt
    function downloadUrlsTxt() {
      const content = sitesTextarea.value.split(/\r?\n/).map(l => l.trim()).filter(Boolean).join('\n');
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'urls.txt';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Load urls.txt from server, merge with any saved extras in localStorage, then populate textarea
    async function loadUrlsTxtAndMerge() {
      loadedCountEl.textContent = 'Loading...';
      let fetched = [];
      try {
        const res = await fetch('/urls.txt?nocache=' + Date.now());
        if (res.ok) {
          const text = await res.text();
          fetched = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
        } else {
          console.warn('urls.txt not found or not accessible:', res.status);
        }
      } catch (e) {
        console.warn('Failed to fetch urls.txt (network/CORS?):', e);
      }

      // Load extras from localStorage
      let extras = [];
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) extras = JSON.parse(raw);
      } catch (e) {
        console.warn('Failed to read extras from localStorage', e);
      }

      // Merge: fetched first, then extras but keep unique order
      const combined = [];
      const seen = new Set();
      for (const u of fetched.concat(extras)) {
        if (!u) continue;
        if (!seen.has(u)) {
          seen.add(u);
          combined.push(u);
        }
      }

      sitesTextarea.value = combined.join('\n');
      loadedCountEl.textContent = combined.length + ' entries loaded (from urls.txt + local additions)';
      saveExtrasFromTextarea();
    }

    // Add a single URL from input to textarea (and save)
    addUrlBtn.addEventListener('click', function() {
      const val = addUrlInput.value.trim();
      if (!val) return;
      const current = parseSites(sitesTextarea.value);
      if (!current.includes(val)) {
        current.push(val);
        sitesTextarea.value = current.join('\n');
        saveExtrasFromTextarea();
        loadedCountEl.textContent = current.length + ' entries loaded (from urls.txt + local additions)';
      }
      addUrlInput.value = '';
      addUrlInput.focus();
    });

    // Remove selected lines => selection-based removal: remove lines that are within selection range
    removeSelectedBtn.addEventListener('click', function() {
      const selStart = sitesTextarea.selectionStart;
      const selEnd = sitesTextarea.selectionEnd;
      const text = sitesTextarea.value;
      if (selStart === selEnd) {
        // no selection: remove all
        if (!confirm('No selection detected. Remove all entries?')) return;
        sitesTextarea.value = '';
        saveExtrasFromTextarea();
        loadedCountEl.textContent = '0 entries loaded';
        return;
      }

      // Determine which lines overlap selection
      const before = text.slice(0, selStart);
      const selected = text.slice(selStart, selEnd);
      const after = text.slice(selEnd);

      // Compute line indices
      const allLines = text.split(/\r?\n/);
      let charCount = 0;
      const keep = [];
      for (let i = 0; i < allLines.length; i++) {
        const line = allLines[i];
        const lineStart = charCount;
        const lineEnd = charCount + line.length;
        charCount += line.length + 1; // +1 for newline
        // If line intersects selection range, skip it
        if (lineEnd < selStart || lineStart >= selEnd) {
          // keep
          if (line.trim()) keep.push(line.trim());
        }
      }

      sitesTextarea.value = keep.join('\n');
      saveExtrasFromTextarea();
      loadedCountEl.textContent = keep.length + ' entries loaded';
    });

    // Download button
    downloadBtn.addEventListener('click', function() {
      downloadUrlsTxt();
    });

    // Autosave changes to localStorage on blur or change
    sitesTextarea.addEventListener('blur', saveExtrasFromTextarea);
    sitesTextarea.addEventListener('change', saveExtrasFromTextarea);
    sitesTextarea.addEventListener('input', function() {
      // update loaded count live
      const count = parseSites(sitesTextarea.value).length;
      loadedCountEl.textContent = count + ' entries (editable)';
    });

    // Load automatically on script run
    loadUrlsTxtAndMerge();

    // --- History flood logic (kept simple & async-friendly) ---
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function ensureFullUrl(u) {
      try {
        return new URL(u).toString();
      } catch (e) {
        try {
          return new URL('https://' + u).toString();
        } catch (e2) {
          return null;
        }
      }
    }

    function buildHistoryPathForUrl(targetUrl, cycleIndex, itemIndex, useHash) {
      const enc = encodeURIComponent(targetUrl);
      const suffix = '?u=' + enc + '&c=' + cycleIndex + '&i=' + itemIndex;
      if (useHash) {
        return '#/flood/?u=' + enc + '&c=' + cycleIndex + '&i=' + itemIndex;
      } else {
        return '/flood/' + suffix;
      }
    }

    function setDocumentFavicon(href) {
      if (!href) return;
      let link = document.querySelector('link[rel="icon"]');
      if (!link) {
        link = document.createElement('link');
        link.rel = 'icon';
        document.head.appendChild(link);
      }
      link.href = href;
      let sc = document.querySelector('link[rel="shortcut icon"]');
      if (!sc) {
        sc = document.createElement('link');
        sc.rel = 'shortcut icon';
        document.head.appendChild(sc);
      }
      sc.href = href;
    }

    // Best-effort: fetch title & icon (may be blocked by CORS)
    async function fetchTitleAndIcon(targetUrl) {
      const result = { title: null, icon: null };
      let parsed;
      try {
        parsed = new URL(targetUrl);
      } catch (e) {
        return result;
      }

      try {
        const resp = await fetch(targetUrl, { mode: 'cors', credentials: 'omit' });
        if (resp && resp.ok) {
          const text = await resp.text();
          const titleMatch = text.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
          if (titleMatch) result.title = titleMatch[1].trim();
          const iconMatch = text.match(/<link[^>]+rel=["']?(?:shortcut icon|icon|apple-touch-icon)["']?[^>]*href=["']([^"']+)["']/i);
          if (iconMatch && iconMatch[1]) {
            try {
              result.icon = new URL(iconMatch[1], parsed.origin).toString();
            } catch (e2) {
              result.icon = iconMatch[1];
            }
          } else {
            result.icon = parsed.origin + '/favicon.ico';
          }
          return result;
        }
      } catch (e) {
        // ignore; fallback
      }

      // fallback to hostname & google favicon
      result.title = parsed.hostname;
      result.icon = 'https://www.google.com/s2/favicons?domain=' + encodeURIComponent(parsed.hostname) + '&sz=64';
      return result;
    }

    async function pushHistoryFromList(sites, cycles, capPerCycle, useHash) {
      const perCycle = capPerCycle && capPerCycle > 0 ? Math.min(capPerCycle, sites.length) : sites.length;
      const total = perCycle * cycles;
      if (total > SAFETY_CAP) {
        if (!confirm('You are about to push ' + total + ' history entries. This may affect browser performance. Continue?')) {
          return false;
        }
      }

      let pushed = 0;
      for (let c = 1; c <= cycles; c++) {
        const shuffled = shuffle(sites.slice());
        const limit = Math.min(perCycle, shuffled.length);

        for (let i = 0; i < limit; i++) {
          const raw = shuffled[i];
          const full = ensureFullUrl(raw);
          const targetUrl = full || raw;
          const historyPath = buildHistoryPathForUrl(targetUrl, c, i + 1, useHash);

          try {
            const info = await fetchTitleAndIcon(targetUrl);
            if (info.icon) setDocumentFavicon(info.icon);
            if (info.title) document.title = info.title;

            // brief delay so browser may register title/favicon change
            await new Promise(res => setTimeout(res, 60));

            history.pushState({}, info.title || document.title, historyPath);
            pushed++;
          } catch (e) {
            console.error('Failed during push for', targetUrl, e);
            alert('Stopping: an error occurred while pushing history entries. See console for details.');
            return false;
          }

          if (pushed % 50 === 0) await new Promise(res => setTimeout(res, 40));
        }
      }

      alert('History flood complete: ' + pushed + ' entries pushed.');
      return true;
    }

    // Manual numeric flood methods
    function floodManualCount(n, numericPaths) {
      n = Math.floor(n);
      if (!n || n < 1) { alert('Enter a positive integer'); return false; }
      if (n > SAFETY_CAP) {
        if (!confirm('You are about to push ' + n + ' entries. This may affect browser performance. Continue?')) return false;
      }

      const originalUrl = window.location.href;
      try {
        for (let i = 1; i <= n; i++) {
          if (numericPaths) {
            history.pushState({}, '/' + i.toString(), '/' + i.toString());
          } else {
            history.pushState({}, i === n ? originalUrl : i.toString(), i === n ? originalUrl : i.toString());
          }
        }
        alert('Manual flood completed: ' + n + ' entries pushed.');
        return true;
      } catch (e) {
        console.error('Manual flood failed:', e);
        alert('Failed during pushState: ' + e);
        return false;
      }
    }

    // Start/preview buttons
    startFloodBtn.addEventListener('click', async function() {
      const sites = parseSites(sitesTextarea.value);
      if (!sites.length) { alert('Please enter or load at least one site in the list.'); return; }
      let cycles = parseInt(cyclesInput.value, 10);
      if (!cycles || cycles < 1) cycles = 1;
      let cap = parseInt(capPerCycleInput.value, 10);
      if (isNaN(cap) || cap < 1) cap = null;
      const useHash = (useFullPathSelect.value === 'hash');

      await pushHistoryFromList(sites, cycles, cap, useHash);
      // persist any edits
      saveExtrasFromTextarea();
    });

    previewBtn.addEventListener('click', function() {
      const sites = parseSites(sitesTextarea.value);
      if (!sites.length) { alert('Please enter or load at least one site in the list to preview.'); return; }
      const useHash = (useFullPathSelect.value === 'hash');
      const shuffled = shuffle(sites.slice());
      const preview = shuffled.slice(0, 5).map((s, idx) => {
        const full = ensureFullUrl(s) || s;
        return (useHash ? '#/flood/?u=' : '/flood/?u=') + encodeURIComponent(full);
      });
      alert('Preview (first 5 entries):\n' + preview.join('\n'));
    });

    // Hook Enter in addUrlInput to trigger add
    addUrlInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        addUrlBtn.click();
      }
    });

    // Allow download by Ctrl+S while modal open (optional)
    document.addEventListener('keydown', function(e) {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's' && document.getElementById('historyModalOverlay').style.display === 'flex') {
        e.preventDefault();
        downloadBtn.click();
      }
    });
  })();
</script>

</body>
</html>
