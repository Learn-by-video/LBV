<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>L.B.V. - Main Page</title>

  <meta name="description" content="L.B.V. - Learn by Video. Explore facts, videos, and games in an interactive educational platform." />
  <meta name="keywords" content="L.B.V, Learn by Video, educational platform, facts, videos, games, learning" />
  <meta name="author" content="L.B.V. Team" />

  <link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Learn-by-video/assets/refs/heads/main/Favcon/l-b-v.jpg">
  <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/Learn-by-video/assets/refs/heads/main/Favcon/l-b-v.jpg">
  <meta name="theme-color" content="#003366">

  <style>
    html, body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #003366;
      color: white;
      text-align: center;
      min-height: 100vh;
    }
    header, footer {
      padding: 20px;
      background: #003366;
    }
    .nav-links { display:flex; gap:12px; justify-content:center; padding:16px; flex-wrap:wrap; }
    .nav-links a { background:white; color:#003366; padding:12px 18px; border-radius:6px; text-decoration:none; font-weight:bold; }
    .version-banner { position: fixed; bottom: 10px; width: 100%; text-align: center; font-size: 0.95em; opacity: 0.8; }

    /* Modal & controls */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      padding: 18px;
    }
    .modal {
      background: #0b0b0b;
      color: #fff;
      border-radius: 12px;
      padding: 20px;
      max-width: 780px;
      width: 100%;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
      text-align: left;
    }
    .modal h2 { margin: 0 0 8px 0; font-size: 20px; text-align:center; }
    label { color:#cfd8dc; font-size:13px; display:block; margin-bottom:6px; }
    textarea { width:100%; min-height:140px; resize:vertical; padding:10px; border-radius:8px; border:none; background:#071017; color:#e6f7f7; font-size:14px; }
    input[type="number"], input[type="text"], select { padding:8px 10px; border-radius:8px; border:none; background:#071017; color:#e6f7f7; font-size:14px; }
    .controls { display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; align-items:center; }
    .btn { background: #00f2ea; color: #000; padding:10px 16px; border-radius:10px; border:none; font-weight:700; cursor:pointer; }
    .btn.secondary { background:#2b2b2b; color:#fff; border:1px solid #444; box-shadow:none; }
    .small { font-size:12px; color:#9aa7ac; }
    .row { display:flex; gap:10px; align-items:center; margin-top:8px; flex-wrap:wrap; }
    .col { display:flex; flex-direction:column; gap:6px; }

    .list-actions { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center; }

    @media (max-width:700px) {
      .modal { padding:14px; }
      textarea { min-height:110px; }
      .controls { flex-direction:column; align-items:stretch; }
    }
  </style>
</head>
<body>

<header>
  <a href="index.html" style="color:white; text-decoration:none; font-size:22px; font-weight:bold;">L.B.V. - Main Page</a>
</header>

<div class="nav-links">
  <a href="/lbv/facts/">Facts</a>
  <a href="/lbv/videos/">Videos</a>
  <a href="/lbv/games/">Games</a>
</div>

<footer>
  <p style="margin:0;">© Learn by Video. All rights reserved.</p>
</footer>

<div class="version-banner">
  Site Version: <span id="siteVersion">Loading...</span>
</div>

<!-- Modal (only opened by shortcut Ctrl+Alt+Shift+Z) -->
<div id="historyModalOverlay" class="modal-overlay" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="modal" role="document">
    <h2>History Flood Tool</h2>

    <label for="sitesList">Sites (one per line) — loaded from urls.txt automatically. You can edit, add, or remove entries here. Changes are saved to local storage and can be downloaded as a new urls.txt.</label>
    <textarea id="sitesList" placeholder="https://example.com/page
https://another.example/path"></textarea>

    <div class="list-actions">
      <input id="addUrlInput" type="text" placeholder="Add a URL and press Add" style="flex:1; min-width:200px;" />
      <button id="addUrlBtn" class="btn">Add</button>
      <button id="removeSelectedBtn" class="btn secondary">Remove Selected Lines</button>
      <button id="downloadBtn" class="btn">Download urls.txt</button>
      <span id="loadedCount" class="small">Loading...</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="col" style="flex:0 0 160px;">
        <label class="small" for="cycles">Cycles</label>
        <input id="cycles" type="number" min="1" value="1" />
      </div>
      <div class="col" style="flex:0 0 200px;">
        <label class="small" for="capPerCycle">Max pushes per cycle (optional)</label>
        <input id="capPerCycle" type="number" min="1" placeholder="leave blank = all" />
      </div>
      <div class="col" style="flex:0 0 160px;">
        <label class="small" for="useFullPath">Push type</label>
        <select id="useFullPath">
          <option value="query">/?u=[url]</option>
          <option value="hash">#?u=[url]</option>
        </select>
      </div>
    </div>

    <div class="controls" style="margin-top:12px;">
      <button id="startFloodBtn" class="btn">Start Flood (from list)</button>
      <button id="previewBtn" class="btn secondary">Preview first 5 entries</button>
      <button id="closeModalBtn" class="btn secondary">Close</button>
    </div>

    <div style="margin-top:12px; text-align:center;" class="small">
      Open this tool with Ctrl + Alt + Shift + Z
    </div>
  </div>
</div>

<script>
  // fetch version if available
  (function fetchVersion(){
    fetch('/version.txt?nocache=' + Date.now())
      .then(r => r.text())
      .then(t => { document.getElementById('siteVersion').textContent = t.trim(); })
      .catch(() => { document.getElementById('siteVersion').textContent = 'Unavailable'; });
  })();

  // --------- Utilities ----------
  function parseSites(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const seen = new Set();
    const out = [];
    for (const l of lines) {
      if (!seen.has(l)) { seen.add(l); out.push(l); }
    }
    return out;
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function ensureFullUrl(u) {
    try { return new URL(u).toString(); }
    catch (e) {
      try { return new URL('https://' + u).toString(); }
      catch (e2) { return null; }
    }
  }

  // fetch with timeout helper
  function fetchWithTimeout(url, opts = {}, timeout = 3000) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    return fetch(url, Object.assign({}, opts, { signal: controller.signal })).finally(() => clearTimeout(id));
  }

  function getCurrentFaviconHref() {
    const link = document.querySelector('link[rel~="icon"]') || document.querySelector('link[rel="shortcut icon"]');
    return link ? link.href : null;
  }

  function setDocumentFavicon(href) {
    if (!href) return;
    let link = document.querySelector('link[rel="icon"]');
    if (!link) {
      link = document.createElement('link');
      link.rel = 'icon';
      document.head.appendChild(link);
    }
    link.href = href;
    let sc = document.querySelector('link[rel="shortcut icon"]');
    if (!sc) {
      sc = document.createElement('link');
      sc.rel = 'shortcut icon';
      document.head.appendChild(sc);
    }
    sc.href = href;
  }

  // wait for image to load (used for favicon) with timeout
  function waitForImageLoad(url, timeout = 1200) {
    return new Promise((resolve) => {
      if (!url) return resolve(false);
      const img = new Image();
      let done = false;
      const t = setTimeout(() => {
        if (!done) { done = true; resolve(false); }
      }, timeout);
      img.onload = () => { if (!done) { done = true; clearTimeout(t); resolve(true); } };
      img.onerror = () => { if (!done) { done = true; clearTimeout(t); resolve(false); } };
      // use crossorigin attribute to increase chance of successful fetch (not guaranteed)
      try { img.crossOrigin = 'anonymous'; } catch (e) {}
      img.src = url;
      // if already cached and complete, load handlers might not fire in some browsers — check immediately
      if (img.complete) {
        if (!done) { done = true; clearTimeout(t); resolve(true); }
      }
    });
  }

  // fetch target page title & icon (best-effort). Uses timeout and fallbacks.
  async function fetchTitleAndIcon(targetUrl) {
    const result = { title: null, icon: null };
    let parsed;
    try { parsed = new URL(targetUrl); } catch (e) { return result; }

    // Try fetch page HTML (CORS may block)
    try {
      const resp = await fetchWithTimeout(targetUrl, { mode: 'cors', credentials: 'omit' }, 3500);
      if (resp && resp.ok) {
        const text = await resp.text();
        const titleMatch = text.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
        if (titleMatch) result.title = titleMatch[1].trim();
        const iconMatch = text.match(/<link[^>]+rel=["']?(?:shortcut icon|icon|apple-touch-icon)["']?[^>]*href=["']([^"']+)["']/i);
        if (iconMatch && iconMatch[1]) {
          try { result.icon = new URL(iconMatch[1], parsed.origin).toString(); }
          catch (e2) { result.icon = iconMatch[1]; }
        } else {
          result.icon = parsed.origin + '/favicon.ico';
        }
        return result;
      }
    } catch (e) {
      // fetch failed (likely CORS) -> fallback
    }

    // fallback: hostname and google favicon service
    result.title = parsed.hostname;
    result.icon = 'https://www.google.com/s2/favicons?domain=' + encodeURIComponent(parsed.hostname) + '&sz=64';
    return result;
  }

  // --------- Modal open/close only via shortcut ----------
  (function modalShortcuts() {
    const overlay = document.getElementById('historyModalOverlay');
    const closeBtn = document.getElementById('closeModalBtn');

    function openModal() {
      overlay.style.display = 'flex';
      overlay.setAttribute('aria-hidden', 'false');
      document.getElementById('sitesList').focus();
    }
    function closeModal() {
      overlay.style.display = 'none';
      overlay.setAttribute('aria-hidden', 'true');
    }

    closeBtn.addEventListener('click', closeModal);
    overlay.addEventListener('click', function(e){ if (e.target === overlay) closeModal(); });

    document.addEventListener('keydown', function(e){
      if (e.ctrlKey && e.altKey && e.shiftKey && (e.key === 'Z' || e.key === 'z')) {
        e.preventDefault();
        if (overlay.style.display === 'flex') closeModal(); else openModal();
      }
      if (e.key === 'Escape' && overlay.style.display === 'flex') closeModal();
    });

    // expose for debugging
    window.openHistoryModal = openModal;
    window.closeHistoryModal = closeModal;
  })();

  // --------- Load urls.txt and manage list ----------
  (function listManagement() {
    const sitesTextarea = document.getElementById('sitesList');
    const loadedCountEl = document.getElementById('loadedCount');
    const addUrlInput = document.getElementById('addUrlInput');
    const addUrlBtn = document.getElementById('addUrlBtn');
    const removeSelectedBtn = document.getElementById('removeSelectedBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    const STORAGE_KEY = 'historyFlood.extraUrls';

    function saveExtrasFromTextarea() {
      const current = parseSites(sitesTextarea.value);
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(current)); } catch (e) { console.warn('Could not save to localStorage', e); }
    }

    function downloadUrlsTxt() {
      const content = sitesTextarea.value.split(/\r?\n/).map(l => l.trim()).filter(Boolean).join('\n');
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'urls.txt';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function loadUrlsTxtAndMerge() {
      loadedCountEl.textContent = 'Loading...';
      let fetched = [];
      try {
        const res = await fetch('/urls.txt?nocache=' + Date.now());
        if (res.ok) {
          const text = await res.text();
          fetched = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
        } else {
          console.warn('urls.txt not found or not accessible:', res.status);
        }
      } catch (e) {
        console.warn('Failed to fetch urls.txt (network/CORS?):', e);
      }

      let extras = [];
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) extras = JSON.parse(raw);
      } catch (e) { console.warn('Failed to read extras from localStorage', e); }

      const combined = [];
      const seen = new Set();
      for (const u of fetched.concat(extras)) {
        if (!u) continue;
        if (!seen.has(u)) { seen.add(u); combined.push(u); }
      }

      sitesTextarea.value = combined.join('\n');
      loadedCountEl.textContent = combined.length + ' entries loaded (from urls.txt + local additions)';
      saveExtrasFromTextarea();
    }

    addUrlBtn.addEventListener('click', function() {
      const val = addUrlInput.value.trim();
      if (!val) return;
      const current = parseSites(sitesTextarea.value);
      if (!current.includes(val)) {
        current.push(val);
        sitesTextarea.value = current.join('\n');
        saveExtrasFromTextarea();
        document.getElementById('loadedCount').textContent = current.length + ' entries loaded (from urls.txt + local additions)';
      }
      addUrlInput.value = '';
      addUrlInput.focus();
    });

    removeSelectedBtn.addEventListener('click', function() {
      const selStart = sitesTextarea.selectionStart;
      const selEnd = sitesTextarea.selectionEnd;
      const text = sitesTextarea.value;
      if (selStart === selEnd) {
        if (!confirm('No selection detected. Remove all entries?')) return;
        sitesTextarea.value = '';
        saveExtrasFromTextarea();
        loadedCountEl.textContent = '0 entries loaded';
        return;
      }

      const allLines = text.split(/\r?\n/);
      let charCount = 0;
      const keep = [];
      for (let i = 0; i < allLines.length; i++) {
        const line = allLines[i];
        const lineStart = charCount;
        const lineEnd = charCount + line.length;
        charCount += line.length + 1;
        if (lineEnd < selStart || lineStart >= selEnd) {
          if (line.trim()) keep.push(line.trim());
        }
      }

      sitesTextarea.value = keep.join('\n');
      saveExtrasFromTextarea();
      loadedCountEl.textContent = keep.length + ' entries loaded';
    });

    downloadBtn.addEventListener('click', downloadUrlsTxt);
    sitesTextarea.addEventListener('blur', saveExtrasFromTextarea);
    sitesTextarea.addEventListener('change', saveExtrasFromTextarea);
    sitesTextarea.addEventListener('input', function() {
      const count = parseSites(sitesTextarea.value).length;
      loadedCountEl.textContent = count + ' entries (editable)';
    });

    // load now
    loadUrlsTxtAndMerge();
  })();

  // --------- History flood (sequential, wait-for-favicon to reduce off-by-one) ----------
  (function historyFlood() {
    const startFloodBtn = document.getElementById('startFloodBtn');
    const previewBtn = document.getElementById('previewBtn');
    const cyclesInput = document.getElementById('cycles');
    const capPerCycleInput = document.getElementById('capPerCycle');
    const useFullPathSelect = document.getElementById('useFullPath');
    const SAFETY_CAP = 5000;

    function buildQueryPath(targetUrl, cycleIndex, itemIndex, useHash) {
      const enc = encodeURIComponent(targetUrl);
      const suffix = 'u=' + enc + '&c=' + cycleIndex + '&i=' + itemIndex;
      if (useHash) return '#?' + suffix;
      return '/?' + suffix;
    }

    // Core: sequentially process items, waiting for each favicon load (or timeout) before pushing the state.
    async function pushHistoryFromList(sites, cycles, capPerCycle, useHash) {
      const perCycle = capPerCycle && capPerCycle > 0 ? Math.min(capPerCycle, sites.length) : sites.length;
      const total = perCycle * cycles;
      if (total > SAFETY_CAP) {
        if (!confirm('You are about to push ' + total + ' history entries. This may affect browser performance. Continue?')) {
          return false;
        }
      }

      const originalTitle = document.title;
      const originalFavicon = getCurrentFaviconHref();

      let pushed = 0;
      for (let c = 1; c <= cycles; c++) {
        const shuffled = shuffle(sites.slice());
        const limit = Math.min(perCycle, shuffled.length);

        for (let i = 0; i < limit; i++) {
          const raw = shuffled[i];
          const full = ensureFullUrl(raw);
          const targetUrl = full || raw;
          const path = buildQueryPath(targetUrl, c, i + 1, useHash);

          try {
            // Get best-effort title/icon (may fallback)
            const info = await fetchTitleAndIcon(targetUrl);

            // Set favicon href so browser will attempt to load it
            if (info.icon) setDocumentFavicon(info.icon);

            // Wait for favicon to actually load (or timeout). This reduces the off-by-one where the previous icon remains.
            await waitForImageLoad(info.icon, 1400).catch(() => false);

            // Set document title (ensure it matches title passed to pushState)
            if (info.title) document.title = info.title;

            // Short extra pause to allow browser to register title change
            await new Promise(res => setTimeout(res, 60));

            // Push the state. Many browsers ignore the title param, but we've set document.title too.
            if (useHash) {
              // use current pathname and push hash
              const newUrl = location.pathname + path;
              history.pushState({}, info.title || document.title, newUrl);
            } else {
              history.pushState({}, info.title || document.title, path);
            }

            pushed++;

            // micro-yield to keep UI responsive on large runs
            if (pushed % 20 === 0) await new Promise(res => setTimeout(res, 60));
          } catch (e) {
            console.error('push failed for', targetUrl, e);
            alert('Stopping: an error occurred while pushing history entries. See console for details.');
            // restore original title/favicon
            if (originalFavicon) setDocumentFavicon(originalFavicon);
            document.title = originalTitle;
            return false;
          }
        }
      }

      // restore original title & favicon after completion (keeps this run as "temporary" visual changes)
      if (originalFavicon) setDocumentFavicon(originalFavicon);
      document.title = originalTitle;

      alert('History flood complete: ' + pushed + ' entries pushed.');
      return true;
    }

    startFloodBtn.addEventListener('click', async function() {
      const sites = parseSites(document.getElementById('sitesList').value);
      if (!sites.length) { alert('Please enter or load at least one site in the list.'); return; }
      let cycles = parseInt(cyclesInput.value, 10);
      if (!cycles || cycles < 1) cycles = 1;
      let cap = parseInt(capPerCycleInput.value, 10);
      if (isNaN(cap) || cap < 1) cap = null;
      const useHash = (useFullPathSelect.value === 'hash');

      await pushHistoryFromList(sites, cycles, cap, useHash);
      try { localStorage.setItem('historyFlood.extraUrls', JSON.stringify(parseSites(document.getElementById('sitesList').value))); } catch (e) {}
    });

    previewBtn.addEventListener('click', function() {
      const sites = parseSites(document.getElementById('sitesList').value);
      if (!sites.length) { alert('Please enter or load at least one site in the list to preview.'); return; }
      const useHash = (useFullPathSelect.value === 'hash');
      const shuffled = shuffle(sites.slice());
      const preview = shuffled.slice(0, 5).map((s, idx) => {
        const full = ensureFullUrl(s) || s;
        return (useHash ? '#?u=' : '/?u=') + encodeURIComponent(full);
      });
      alert('Preview (first 5 entries):\n' + preview.join('\n'));
    });

    // Expose for debugging
    window._historyFlood_pushFromList = pushHistoryFromList;
  })();

  // --------- If loaded with ?u=(url) clone title & favicon for that single view ----------
  (function handleIncomingQueryU() {
    async function run() {
      const params = new URLSearchParams(window.location.search);
      const uParam = params.get('u');
      if (!uParam) return;
      let target;
      try { target = decodeURIComponent(uParam); } catch (e) { target = uParam; }
      const full = ensureFullUrl(target) || target;

      const originalTitle = document.title;
      const originalFavicon = getCurrentFaviconHref();

      try {
        const info = await fetchTitleAndIcon(full);
        if (info.icon) {
          setDocumentFavicon(info.icon);
          await waitForImageLoad(info.icon, 1400).catch(() => false);
        }
        if (info.title) document.title = info.title;
        history.replaceState({}, info.title || document.title, window.location.pathname + window.location.search);
      } catch (e) {
        console.warn('Failed to fetch title/icon for ?u target (CORS may block). Using fallback.', e);
        const info = await fetchTitleAndIcon(full);
        if (info.icon) {
          setDocumentFavicon(info.icon);
          await waitForImageLoad(info.icon, 1200).catch(() => false);
        }
        if (info.title) document.title = info.title;
        history.replaceState({}, info.title || document.title, window.location.pathname + window.location.search);
      }
      // Do not restore original; this view is intentionally representing the target.
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', run);
    } else {
      run();
    }
  })();
</script>

</body>
</html>
